//basic.h

#ifndef BASIC_H_INCLUDED
#define BASIC_H_INCLUDED
#define SIZE 100
#include<iostream>
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
#include<iomanip>
using namespace std;
void print(int Arr[],int n){
    cout << endl;
    for(size_t i=0;i<n;++i){
        cout << setw(5) << Arr[i];
        if((i+1)%10==0)
            cout << endl;
    }
        cout << endl;
}
void create(int Arr[],int n){
    for(size_t i=0;i<n-1;++i)
    Arr[i] = rand()%1000;
    cout << "A new example is created as:";
    print(Arr,n);
}

void selectionSort(int Arr[],int n){
    for(size_t i=0;i<n-1;++i){
        size_t Min = i;
        for(size_t j=i+1;j<n;j++){
            if(Arr[j]<Arr[Min])
                Min = j;
        }
        swap(Arr[i],Arr[Min]);
    }
    cout << "after selection sort:";
    print(Arr,n);
}//1.选择排序，将第一个与最小的交换...将第i个与剩余n-i个中最小的交换：O(n²)。
void recVer(int Arr[],int n){
    if(n>1){
        size_t Min = 0;
        for(size_t j=1;j<n;j++){
            if(Arr[j]<Arr[Min])
                Min = j;
        }//确定数组中最小的元素
        swap(Arr[0],Arr[Min]);//将其与第一个元素交换
        recVer(Arr+1,n-1);
        }
}
void selectionSortRecursion(int Arr[],int n){
    recVer(Arr,n);
    cout << "after selection sort(recursion version):";
    print(Arr,n);
    cout << endl;
}//1.5选择排序的一个递归版本。其他排序的循环也可以更改为递归。

void insertionSort(int Arr[],int n){
    for(size_t i=1;i<n;i++){
        size_t moveItem = i;//记录欲插入的位置
        int ins = Arr[i];//计划插入的元素，故i=1（从第二个开始）

        while(moveItem > 0 && Arr[moveItem - 1] > ins){
            Arr[moveItem] = Arr[moveItem - 1];//前一个元素后移一位
            --moveItem;
        }
        Arr[moveItem] = ins;
    }
    cout << "after insertion sort:";
    print(Arr,n);
}//2.插入排序，加入第2个元素，将第2个元素依序插入前1个元素中...加入第i个元素，将第i个元素依序插入前i-1个元素中:O(n²)。
void shellSort(int Arr[],int n){
    int step,temp;
    for(step=n/2;step>0;step/=2){//分组：此处选择折半向下为增量，每次减半直到为1
        for(int i=step;i<n;i++){//分别向每组的有序区域插入
            temp = Arr[i];
            int j;
            for(j=i-step;j>=i%step&&temp<Arr[j];j-=step)
                Arr[j+step] = Arr[j];//前一个元素后移STEP位
            if(j!=i-step)
            Arr[j+step] = temp;//插入
        }
    }
    cout << "after shell sort:";
    print(Arr,n);
    cout << endl;
}//2.5.这是插入排序的一种改进版本：希尔排序:O(n²)。我们暂时不作步长选择的讨论。还有折半插入方法：插入时折半查找，因为没有本质改变，没有列举。

void bubbleSort(int Arr[],int n){
    for(size_t pass=1;pass<n;++pass){
        for(int i=0;i<n-pass;++i){
            if(Arr[i]>Arr[i+1])
                swap(Arr[i],Arr[i+1]);
        }
    }
    cout << "after bubble sort:";
    print(Arr,n);
    cout << endl;
}//3.冒泡排序，第一次两两相邻比较使最大的到最后...第pass次两两相邻比较使最大的到最后：O(n²)。

void Merge(int Arr[],size_t left,size_t mid1,size_t mid2,size_t right){
    size_t leftIndex = left;//第一部分 起始
    size_t rightIndex = mid2;//第二部分 起始
    size_t combinedIndex = left;//整体 起始
    int temp[5000];
    while(leftIndex<=mid1 && rightIndex<=right){
        if(Arr[leftIndex] <= Arr[rightIndex])
            temp[combinedIndex++] = Arr[leftIndex++];
        else
            temp[combinedIndex++] = Arr[rightIndex++];
    }//若第一部分元素小，则if语句将其放入数组。若第二部分元素小，else语句将其放入数组。
    if(leftIndex == mid2)//第一部分到头：第二部分有余
        while(rightIndex<=right)
            temp[combinedIndex++] = Arr[rightIndex++];
    else////第二部分到头：第一部分有余
        while(leftIndex<=mid1)
            temp[combinedIndex++] = Arr[leftIndex++];//处理到达末尾的情况
    for(size_t i=0;i<=right;++i)
        Arr[i] = temp[i];
}
void sortSubArray(int Arr[],size_t low,size_t high){
    if((high - low) >= 1){//基线条件：数组只有一个元素
        size_t mid1 = (high + low)/2;
        size_t mid2 = mid1 + 1;
        sortSubArray(Arr,low,mid1);
        sortSubArray(Arr,mid2,high); //如果大于1，将该数组一分为二，分别排序
        Merge(Arr,low,mid1,mid2,high);//分别排序后将两个数组合并
    }}
void mergeSort(int Arr[],int n){
    sortSubArray(Arr,0,n-1);
    cout << "after merge sort:";
    print(Arr,n);
    cout << endl;
}//4.合并排序：（递归树的特性）每升高i个层次，数组大小是原来的i²倍：O(n*logn))。

void bucketSort(int Arr[],int n){
    int buc[1000]={0};//建立针对每个值的桶
    for(int i=0;i<n;++i)
        ++buc[Arr[i]];//依序向桶内放置记录
    int k = 0;
    for(int i=0;i<1000;++i){//外序
        for(int j=0;j<buc[i];++j){//内序
            Arr[k++]=i;}//输出桶的索引即数组元素
    }
    cout << "after bucket sort:";
    print(Arr,n);
    cout << endl;
}//5.桶式排序：分桶，分别按桶内序和外序输出，有其他的分桶方式（见5.5）和数据结构实现方式,这里演示了计数排序：O(1)。
int getDigitInpos(int num,int pos){
    int temp = 1;
    for(int i=0;i<pos-1;++i)
        temp *= 10;
    return (num/temp)%10;
}//寻找第pos位的数据
void radixSort(int Arr[],int n){
    int* radix[10];
    for(int i=0;i<10;++i){
        radix[i] = (int*)malloc(sizeof(int)*(n+1));//new int[n+1];
        radix[i][0] = 0;//0位用于记录数据的个数
    }
    for(int pos = 1;pos<=10;++pos){//此处意为最多十位数
        for(int i=0;i<n;++i){
            int num = getDigitInpos(Arr[i],pos);
            int index = ++radix[num][0];
            radix[num][index] = Arr[i];
        }//分配
    for(int i=0,j=0;i<10;++i){
        for(int k=1;k<=radix[i][0];++k)
            Arr[j++] = radix[i][k];
        radix[i][0] = 0;
        }//出桶并复位
    }
    cout << "after radix sort:";
    print(Arr,n);
    cout << endl;
}
//5.5 除计数分桶以外其他的分桶方法（基数排序(基数一般为10，取决于进制)）：按第i（i从个位递增到最高）位数比较大小，十个一组分桶之后归并：O(n)。


void quickRec(int Arr[],int left,int right){
    int l=left;
    int r=right;
    int key=Arr[left];
    while(l<r){
            while(l<r && Arr[r]>=key)
                r--;//从右边开始大于key的第一个元素
            if(l<r)
                Arr[l++] = Arr[r];
            while(l<r && Arr[l]<=key)
                l++;//从左边开始小于key的第一个元素
            if(l<r)
                Arr[r--] = Arr[l];
    }
    Arr[l] = key;//交换使得key处于正确的位置
    if(left>=right) return;

    int mid = l;
    quickRec(Arr,left,mid);
    quickRec(Arr,mid+1,right);//对key左右两部分分别快排
}
void quickSort(int Arr[],int n){
    cout << "after quick sort:";
    quickRec(Arr,0,n-1);
    print(Arr,n);
    cout << endl;
}//6.快速排序：以选定键位基准左右分大小，直到选定键处于正确的大小位置。对左右部分分别递归操作：O(n*logn)。

void HeapAdjust(int Arr[],int i,int n){
    int temp = Arr[i];
    for(int j=2*i;j<=n;j*=2){//2*i是i的左节点，2*i+1是i的右节点：请参考“完全二叉树”
        if(j<n && Arr[j]<Arr[j+1])
            ++j;
        if(temp >= Arr[j])
            break;
        Arr[i] = Arr[j];
        i = j;
    }
    Arr[i] = temp;}//将节点大的元素交换到前面。
void heapSort(int Arr[],int n){
    for(int i=n/2;i>=0;--i)//从倒数第二排节点向前建立完全二叉树:可以在数据结构时再详细讨论
        HeapAdjust(Arr,i,n);
    for(int i=n;i>=0;--i){//循环每个节点，将大的节点交换到堆顶
    swap(Arr[i],Arr[0]);
    HeapAdjust(Arr,0,i-1);
    }
    cout<<"after heap sort:";
    print(Arr,n);
    cout << endl;
}//7.堆排序：利用完全二元树的高效数据结构遍历排序：O(n)。


#endif // BASIC_H_INCLUDED
#include<stdlib.h>
#include<time.h>
#include"basic.h"
#define SIZE 100

int main()
{
    std::cout << "It's a show group of different sort:\n";
    srand(time(NULL));
    int b[SIZE];

    create(b,SIZE);
    selectionSort(b,SIZE);
    create(b,SIZE);
    selectionSortRecursion(b,SIZE);

    create(b,SIZE);
    insertionSort(b,SIZE);
    create(b,SIZE);
    shellSort(b,SIZE);

    create(b,SIZE);
    bubbleSort(b,SIZE);

    create(b,SIZE);
    mergeSort(b,SIZE);

    create(b,SIZE);
    bucketSort(b,SIZE);
    create(b,SIZE);
    radixSort(b,SIZE);

    create(b,SIZE);
    quickSort(b,SIZE);

    create(b,SIZE);
    heapSort(b,SIZE);
    return 0;
}
